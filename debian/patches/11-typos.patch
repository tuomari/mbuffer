Description: Fix some grammatical and typographical errors.
Author: Peter Pentchev <roam@ringlet.net>
Forwarded: not-yet
Last-Update: 2014-10-22

--- a/mbuffer.c
+++ b/mbuffer.c
@@ -527,22 +527,22 @@
 
 static int promptInteractive(unsigned at, unsigned num)
 {
-	static const char prompt[] = "\nContinue with next volume? Press 'y' to continue or 'n' to finish...";
-	static const char contmsg[] = "\nyes - continuing with next volume...\n";
-	static const char donemsg[] = "\nno - input done, waiting for output to finish...\n";
+	static const char prompt[] = "\nContinue with the next volume? Press 'y' to continue or 'n' to finish...";
+	static const char contmsg[] = "\nyes - continue with the next volume...\n";
+	static const char donemsg[] = "\nno - input done, wait for the output to finish...\n";
 	int err;
 
 	err = pthread_mutex_lock(&TermMut);
 	assert(0 == err);
 	if (-1 == write(STDERR_FILENO,prompt,sizeof(prompt))) {
-		errormsg("error accessing controlling terminal for manual volume change request: %s\nConsider using autoload option, when running mbuffer without terminal.\n",strerror(errno));
+		errormsg("error accessing the controlling terminal for a manual volume change request: %s\nConsider using the autoload option when running mbuffer without a terminal.\n",strerror(errno));
 		Terminate = 1;
 		pthread_exit((void *) -1);
 	}
 	for (;;) {
 		char c = 0;
 		if (-1 == read(STDERR_FILENO,&c,1) && (errno != EINTR)) {
-			errormsg("error accessing controlling terminal for manual volume change request: %s\nConsider using autoload option, when running mbuffer without terminal.\n",strerror(errno));
+			errormsg("error accessing the controlling terminal for a manual volume change request: %s\nConsider using the autoload option when running mbuffer without a terminal.\n",strerror(errno));
 			Terminate = 1;
 			pthread_exit((void *) -1);
 		}
@@ -617,19 +617,19 @@
 				(void) snprintf(cmd_buf, sizeof(cmd_buf), "mt -f %s offline", Infile);
 				cmd = cmd_buf;
 			}
-			infomsg("requesting new input volume with command '%s'\n",cmd);
+			infomsg("requesting a new input volume with command '%s'\n",cmd);
 			ret = system(cmd);
 			if (0 < ret) {
-				warningmsg("error running \"%s\" to change volume in autoloader: exitcode %d\n",cmd,ret);
+				warningmsg("error running \"%s\" to change the volume in the autoloader: exitcode %d\n",cmd,ret);
 				Terminate = 1;
 				pthread_exit((void *) 0);
 			} else if (0 > ret) {
-				errormsg("error starting \"%s\" to change volume in autoloader: %s\n", cmd, strerror(errno));
+				errormsg("error starting \"%s\" to change the volume in the autoloader: %s\n", cmd, strerror(errno));
 				Terminate = 1;
 				pthread_exit((void *) -1);
 			}
 			if (AutoloadTime) {
-				infomsg("waiting for drive to get ready...\n");
+				infomsg("waiting for the drive to get ready...\n");
 				(void) sleep(AutoloadTime);
 			}
 		} else {
@@ -648,7 +648,7 @@
 	} while (In == -1);
 	(void) gettimeofday(&volstart,0);
 	diff = volstart.tv_sec - now.tv_sec + (double) (volstart.tv_usec - now.tv_usec) * 1E-6;
-	infomsg("tape-change took %fsec. - continuing with next volume\n",diff);
+	infomsg("tape-change took %fsec. - continuing with the next volume\n",diff);
 	NumVolumes--;
 	if (Terminal && ! Autoloader) {
 		char msg[] = "\nOK - continuing...\n";
@@ -877,17 +877,17 @@
 	else if (S_ISBLK(st.st_mode) || S_ISCHR(st.st_mode)) {
 		infomsg("blocksize is %d bytes on output device\n",st.st_blksize);
 		if ((Blocksize < st.st_blksize) || (Blocksize % st.st_blksize != 0)) {
-			warningmsg("Blocksize should be a multiple of the blocksize of the output device!\n"
+			warningmsg("The blocksize should be a multiple of the blocksize of the output device!\n"
 				"This can cause problems with some device/OS combinations...\n"
-				"Blocksize on output device %s is %d (transfer block size is %lld)\n", dest->arg, st.st_blksize, Blocksize);
+				"The blocksize on output device %s is %d (the transfer block size is %lld)\n", dest->arg, st.st_blksize, Blocksize);
 			if (SetOutsize) {
-				errormsg("unable to set output blocksize\n");
+				errormsg("unable to set the output blocksize\n");
 				dest->result = strerror(errno);
 				terminateSender(out,dest,1);
 			}
 		} else {
 			if (SetOutsize) {
-				infomsg("setting output blocksize to %d\n",st.st_blksize);
+				infomsg("setting the output blocksize to %d\n",st.st_blksize);
 				outsize = st.st_blksize;
 			}
 		}
@@ -1015,7 +1015,7 @@
 
 	if (!outfile) {
 		errormsg("End of volume, but not end of input:\n"
-			"Output file must be given (option -o) for multi volume support!\n");
+			"An output file must be specified (option -o) for multi-volume support!\n");
 		return -1;
 	}
 	infomsg("end of volume - last block on volume: %lld\n",Numout);
@@ -1050,14 +1050,14 @@
 				(void) snprintf(cmd_buf, sizeof(cmd_buf), default_cmd, Infile);
 				cmd = cmd_buf;
 			}
-			infomsg("requesting new output volume with command '%s'\n",cmd);
+			infomsg("requesting a new output volume with command '%s'\n",cmd);
 			err = system(cmd);
 			if (0 < err) {
-				errormsg("error running \"%s\" to change volume in autoloader - exitcode %d\n", cmd, err);
+				errormsg("error running \"%s\" to change the volume in the autoloader - exitcode %d\n", cmd, err);
 				Autoloader = 0;
 				return -1;
 			} else if (0 > err) {
-				errormsg("error starting \"%s\" to change volume in autoloader: %s\n", cmd, strerror(errno));
+				errormsg("error starting \"%s\" to change the volume in the autoloader: %s\n", cmd, strerror(errno));
 				Autoloader = 0;
 				return -1;
 			}
@@ -1070,18 +1070,18 @@
 			char c = 0, msg[] = "\nvolume full - insert new media and press return when ready...\n";
 			if (Terminal == 0) {
 				errormsg("End of volume, but not end of input.\n"
-					"Specify an autoload command, if you are working without terminal.\n");
+					"Specify an autoload command if you are working without a terminal.\n");
 				return -1;
 			}
 			err = pthread_mutex_lock(&TermMut);
 			assert(0 == err);
 			if (-1 == write(STDERR_FILENO,msg,sizeof(msg))) {
-				errormsg("error accessing controlling terminal for manual volume change request: %s\nConsider using autoload option, when running mbuffer without terminal.\n",strerror(errno));
+				errormsg("error accessing the controlling terminal for a manual volume change request: %s\nConsider using the autoload option when running mbuffer without a terminal.\n",strerror(errno));
 				return -1;
 			}
 			do {
 				if (-1 == read(STDERR_FILENO,&c,1) && (errno != EINTR)) {
-					errormsg("error accessing controlling terminal for manual volume change request: %s\nConsider using autoload option, when running mbuffer without terminal.\n",strerror(errno));
+					errormsg("error accessing the controlling terminal for a manual volume change request: %s\nConsider using the autoload option when running mbuffer without a terminal.\n",strerror(errno));
 					return -1;
 				}
 			} while (c != '\n');
@@ -1101,7 +1101,7 @@
 	} while (-1 == out);
 	(void) gettimeofday(&volstart,0);
 	diff = volstart.tv_sec - now.tv_sec + (double) (volstart.tv_usec - now.tv_usec) * 1E-6;
-	infomsg("tape-change took %fsec. - continuing with next volume\n",diff);
+	infomsg("tape-change took %fsec. - continuing with the next volume\n",diff);
 	if (Terminal && ! Autoloader) {
 		char msg[] = "\nOK - continuing...\n";
 		(void) write(STDERR_FILENO,msg,sizeof(msg));
@@ -1132,7 +1132,7 @@
 	if (TermQ[1] != -1) {
 		err = write(TermQ[1],"0",1);
 		if (err == -1)
-			errormsg("error writing to termination queue: %s\n",strerror(errno));
+			errormsg("error writing to the termination queue: %s\n",strerror(errno));
 	}
 	if (status) {
 		(void) sem_post(&Dev2Buf);
@@ -1351,7 +1351,7 @@
 	(void) fprintf(stderr,
 		"mbuffer version "VERSION"\n"\
 		"Copyright 2001-2014 - T. Maier-Komor\n"\
-		"License: GPLv3 - see file LICENSE\n"\
+		"License: GPLv3 - see the LICENSE file\n"\
 		"This program comes with ABSOLUTELY NO WARRANTY!!!\n"
 		"Donations via PayPal to thomas@maier-komor.de are welcome and support this work!\n"
 		"\n"
@@ -1372,54 +1372,54 @@
 	(void) fprintf(stderr,
 		"usage: mbuffer [Options]\n"
 		"Options:\n"
-		"-b <num>   : use <num> blocks for buffer (default: %ld)\n"
+		"-b <num>   : use <num> blocks for the buffer (default: %ld)\n"
 		"-s <size>  : use blocks of <size> bytes for processing (default: %llu)\n"
 #if defined(_SC_AVPHYS_PAGES) && defined(_SC_PAGESIZE) && !defined(__CYGWIN__) || defined(__FreeBSD__)
-		"-m <size>  : memory <size> of buffer in b,k,M,G,%% (default: 2%% = %llu%c)\n"
+		"-m <size>  : memory <size> of the buffer in b,k,M,G,%% (default: 2%% = %llu%c)\n"
 #else
-		"-m <size>  : memory <size> of buffer in b,k,M,G,%% (default: %llu%c)\n"
+		"-m <size>  : memory <size> of the buffer in b,k,M,G,%% (default: %llu%c)\n"
 #endif
 #ifdef _POSIX_MEMLOCK_RANGE
-		"-L         : lock buffer in memory (unusable with file based buffers)\n"
+		"-L         : lock the buffer in memory (unusable with file based buffers)\n"
 #endif
-		"-d         : use blocksize of device for output\n"
+		"-d         : use the blocksize of the device for output\n"
 		"-D <size>  : assumed output device size (default: infinite/auto-detect)\n"
-		"-P <num>   : start writing after buffer has been filled more than <num>%%\n"
-		"-p <num>   : start reading after buffer has been filled less than <num>%%\n"
+		"-P <num>   : start writing after the buffer has been filled more than <num>%%\n"
+		"-p <num>   : start reading after the buffer has been filled less than <num>%%\n"
 		"-i <file>  : use <file> for input\n"
 		"-o <file>  : use <file> for output (this option can be passed MULTIPLE times)\n"
-		"--append   : append to output file (must be passed before -o)\n"
-		"--truncate : truncate next file (must be passed before -o)\n"
+		"--append   : append to the output file (must be passed before -o)\n"
+		"--truncate : truncate the next file (must be passed before -o)\n"
 		"-I <h>:<p> : use network port <port> as input, allow only host <h> to connect\n"
 		"-I <p>     : use network port <port> as input\n"
 		"-O <h>:<p> : output data to host <h> and port <p> (MUTLIPLE outputs supported)\n"
 		"-n <num>   : <num> volumes for input, '0' to prompt interactively\n"
-		"-t         : use memory mapped temporary file (for huge buffer)\n"
-		"-T <file>  : as -t but uses <file> as buffer\n"
+		"-t         : use a memory mapped temporary file (for a huge buffer)\n"
+		"-T <file>  : as -t but uses <file> as the buffer\n"
 		"-l <file>  : use <file> for logging messages\n"
 		"-u <num>   : pause <num> milliseconds after each write\n"
-		"-r <rate>  : limit read rate to <rate> B/s, where <rate> can be given in b,k,M,G\n"
-		"-R <rate>  : same as -r for writing; use eiter one, if your tape is too fast\n"
+		"-r <rate>  : limit the read rate to <rate> B/s, where <rate> can be given in b,k,M,G\n"
+		"-R <rate>  : same as -r for writing; use either one if your tape is too fast\n"
 		"-f         : overwrite existing files\n"
-		"-a <time>  : autoloader which needs <time> seconds to reload\n"
-		"-A <cmd>   : issue command <cmd> to request new volume\n"
-		"-v <level> : set verbose level to <level> (valid values are 0..6)\n"
+		"-a <time>  : the autoloader needs <time> seconds to reload\n"
+		"-A <cmd>   : issue command <cmd> to request a new volume\n"
+		"-v <level> : set the verbosity level to <level> (valid values are 0..6)\n"
 		"-q         : quiet - do not display the status on stderr\n"
 		"-Q         : quiet - do not log the status\n"
 		"-c         : write with synchronous data integrity support\n"
 		"-e         : stop processing on any kind of error\n"
 #ifdef O_DIRECT
-		"--direct   : open input and output with O_DIRECT\n"
+		"--direct   : open the input and the output with O_DIRECT\n"
 #endif
 #if defined HAVE_LIBCRYPTO || defined HAVE_LIBMD5 || defined HAVE_LIBMHASH
 		"-H\n"
-		"--md5      : generate md5 hash of transfered data\n"
-		"--hash <a> : use alogritm <a>, if <a> is 'list' possible algorithms are listed\n"
+		"--md5      : generate a md5 hash of transferred data\n"
+		"--hash <a> : use algorithm <a>, if <a> is 'list' the possible algorithms are listed\n"
 #endif
 		"-4         : force use of IPv4\n"
 		"-6         : force use of IPv6\n"
 		"-0         : use IPv4 or IPv6\n"
-		"--tcpbuffer: size for TCP buffer\n"
+		"--tcpbuffer: size for the TCP buffer\n"
 		"-V\n"
 		"--version  : print version information\n"
 		"Unsupported buffer options: -t -Z -B\n"
@@ -1472,9 +1472,9 @@
 			return (unsigned long long) d;
 		default:
 			if (argv[c][-2] == '-')
-				fatal("unrecognized size charakter \"%c\" for option \"%s\"\n",ch,&argv[c][-2]);
+				fatal("unrecognized size character \"%c\" for option \"%s\"\n",ch,&argv[c][-2]);
 			else
-				fatal("unrecognized size charakter \"%c\" for option \"%s\"\n",ch,argv[c-1]);
+				fatal("unrecognized size character \"%c\" for option \"%s\"\n",ch,argv[c-1]);
 			return d;
 		}
 	case 1:
@@ -1669,7 +1669,7 @@
 	dfname[sizeof(dfname)-1] = 0;
 	l = strlen(dfname);
 	if (l + 12 > PATH_MAX) {
-		warningmsg("path to defaults file breaks PATH_MAX\n");
+		warningmsg("the path to the defaults file exceeds PATH_MAX characters\n");
 		return;
 	}
 	strcat(dfname,"/.mbuffer.rc");
@@ -1678,20 +1678,20 @@
 		if (errno == ENOENT)
 			infomsg("no defaults file ~/.mbuffer.rc\n");
 		else
-			warningmsg("error opening defaults file %s: %s\n",dfname,strerror(errno));
+			warningmsg("error opening the defaults file %s: %s\n",dfname,strerror(errno));
 		return;
 	}
 	if (-1 == fstat(df,&st)) {
-		warningmsg("unable to stat defaults file %s: %s\n",dfname,strerror(errno));
+		warningmsg("unable to stat the defaults file %s: %s\n",dfname,strerror(errno));
 		close(df);
 		return;
 	}
 	if (getuid() != st.st_uid) {
-		warningmsg("ignoring defaults file from different user\n");
+		warningmsg("ignoring a defaults file owned by a different user\n");
 		close(df);
 		return;
 	}
-	infomsg("reading defaults file %s\n",dfname);
+	infomsg("reading the defaults file %s\n",dfname);
 	dfstr = fdopen(df,"r");
 	assert(dfstr);
 	while (!feof(dfstr)) {
@@ -1790,7 +1790,7 @@
 		}
 		const char *argerror = calcval(valuestr,&value);
 		if (argerror) {
-			warningmsg("ignoring key/value pair from defaults file (%s = %s): %s\n",key,valuestr,argerror);
+			warningmsg("ignoring a key/value pair from the defaults file (%s = %s): %s\n",key,valuestr,argerror);
 			continue;
 		}
 		if (strcasecmp(key,"blocksize") == 0) {
@@ -1805,7 +1805,7 @@
 				Totalmem = ((unsigned long long) NumP * PgSz * value) / 100 ;
 				debugmsg("Totalmem = %lluk\n",Totalmem>>10);
 #else
-				warningmsg("Unable to determine page size or amount of available memory - please specify an absolute amount of memory.\n");
+				warningmsg("Unable to determine the page size or the amount of available memory - please specify an absolute amount of memory.\n");
 #endif
 			}
 		} else if (strcasecmp(key,"tcpbuffer") == 0) {
@@ -1893,13 +1893,13 @@
 			optSset = 1;
 			debugmsg("Blocksize = %llu\n",Blocksize);
 			if (Blocksize < 100)
-				fatal("cannot set blocksize as percentage of total physical memory\n");
+				fatal("cannot set the blocksize as a percentage of the total physical memory\n");
 		} else if (!strcmp("--append",argv[c])) {
 			optMode |= O_APPEND;
-			debugmsg("append to next file\n");
+			debugmsg("append to the next file\n");
 		} else if (!strcmp("--truncate",argv[c])) {
 			optMode |= O_TRUNC;
-			debugmsg("truncate next file\n");
+			debugmsg("truncate the next file\n");
 		} else if (!argcheck("-m",argv,&c,argc)) {
 			Totalmem = calcint(argv,c,Totalmem);
 			optMset = 1;
@@ -1907,7 +1907,7 @@
 #if defined(_SC_AVPHYS_PAGES) && defined(_SC_PAGESIZE) && !defined(__CYGWIN__) || defined(__FreeBSD__)
 				Totalmem = ((unsigned long long) NumP * PgSz * Totalmem) / 100 ;
 #else
-				fatal("Unable to determine page size or amount of available memory - please specify an absolute amount of memory.\n");
+				fatal("Unable to determine the page size or the amount of available memory - please specify an absolute amount of memory.\n");
 #endif
 			}
 			debugmsg("Totalmem = %lluk\n",Totalmem>>10);
@@ -1926,9 +1926,9 @@
 		} else if (!argcheck("-d",argv,&c,argc)) {
 #ifdef HAVE_STRUCT_STAT_ST_BLKSIZE
 			SetOutsize = 1;
-			debugmsg("setting output size according to the blocksize of the device\n");
+			debugmsg("setting the output size according to the blocksize of the device\n");
 #else
-			fatal("cannot determine blocksize of device (unsupported by OS)\n");
+			fatal("cannot determine the blocksize of the device (unsupported by the OS)\n");
 #endif
 		} else if (!argcheck("-v",argv,&c,argc)) {
 			/* has been parsed already */
@@ -1953,7 +1953,7 @@
 			else
 				NumVolumes = nv;
 			if (NumVolumes < 0)
-				fatal("argument for number of volumes must be > 0\n");
+				fatal("the argument for the number of volumes must be > 0\n");
 			debugmsg("NumVolumes = %d\n",NumVolumes);
 		} else if (!argcheck("-i",argv,&c,argc)) {
 			if (strcmp(argv[c],"-")) {
@@ -2026,7 +2026,7 @@
 			Log = open(argv[c],O_WRONLY|O_APPEND|O_TRUNC|O_CREAT|LARGEFILE,0666);
 			if (-1 == Log) {
 				Log = STDERR_FILENO;
-				errormsg("error opening log file: %s\n",strerror(errno));
+				errormsg("error opening the log file: %s\n",strerror(errno));
 			}
 			debugmsg("logFile set to %s\n",argv[c]);
 		} else if (!strcmp("-f",argv[c])) {
@@ -2062,7 +2062,7 @@
 				StartWrite = 0;
 			StartWrite /= 100;
 			if ((StartWrite > 1) || (StartWrite <= 0))
-				fatal("error in argument -P: must be bigger than 0 and less or equal 100\n");
+				fatal("error in argument -P: must be greater than 0 and less than or equal to 100\n");
 			debugmsg("StartWrite = %1.2lf\n",StartWrite);
 		} else if (!argcheck("-p",argv,&c,argc)) {
 			if (1 == sscanf(argv[c],"%lf",&StartRead))
@@ -2070,7 +2070,7 @@
 			else
 				StartRead = 1.0;
 			if ((StartRead >= 1) || (StartRead < 0))
-				fatal("error in argument -p: must be bigger or equal to 0 and less than 100\n");
+				fatal("error in argument -p: must be greater than or equal to 0 and less than 100\n");
 			debugmsg("StartRead = %1.2lf\n",StartRead);
 		} else if (!strcmp("-L",argv[c])) {
 #ifdef _POSIX_MEMLOCK_RANGE
@@ -2084,7 +2084,7 @@
 			if (Timeout <= 0)
 				fatal("invalid argument to option -W\n");
 			if (Timeout <= AutoloadTime)
-				fatal("timeout must be bigger than autoload time\n");
+				fatal("the timeout must be bigger than the autoload time\n");
 		} else if (!strcmp("--direct",argv[c])) {
 #ifdef O_DIRECT
 			debugmsg("using O_DIRECT to open file descriptors\n");
@@ -2137,30 +2137,30 @@
 
 	/* consistency check for options */
 	if (AutoloadTime && Timeout && Timeout <= AutoloadTime)
-		fatal("autoload time must be smaller than watchdog timeout\n");
+		fatal("the autoload time must be smaller than the watchdog timeout\n");
 	if (optBset&optSset&optMset) {
 		if (Numblocks * Blocksize != Totalmem)
 			fatal("inconsistent options: blocksize * number of blocks != totalsize!\n");
 	} else if (((!optBset)&optSset&optMset) || (optMset&(!optBset)&(!optSset))) {
 		if (Totalmem <= Blocksize)
-			fatal("total memory must be larger than block size\n");
+			fatal("the total memory must be larger than the block size\n");
 		Numblocks = Totalmem / Blocksize;
 		infomsg("Numblocks = %llu, Blocksize = %llu, Totalmem = %llu\n",(unsigned long long)Numblocks,(unsigned long long)Blocksize,(unsigned long long)Totalmem);
 	} else if (optBset&!optSset&optMset) {
 		if (Blocksize == 0)
-			fatal("blocksize must be greater than 0\n");
+			fatal("the blocksize must be greater than 0\n");
 		if (Totalmem <= Blocksize)
-			fatal("total memory must be larger than block size\n");
+			fatal("the total memory must be larger than the blocksize\n");
 		Blocksize = Totalmem / Numblocks;
 		infomsg("blocksize = %llu\n",(unsigned long long)Blocksize);
 	}
 	if ((StartRead < 1) && (StartWrite > 0))
-		fatal("setting both low watermark and high watermark doesn't make any sense...\n");
+		fatal("setting both a low watermark and a high watermark doesn't make any sense...\n");
 	if ((NumSenders-Hashers > 0) && (Autoloader || OutVolsize))
 		fatal("multi-volume support is unsupported with multiple outputs\n");
 	if (Autoloader) {
 		if ((!outfile) && (!Infile))
-			fatal("Setting autoloader time without using a device doesn't make any sense!\n");
+			fatal("Setting the autoloader time without using a device doesn't make any sense!\n");
 		if (outfile && Infile) {
 			fatal("Which one is your autoloader? Input or output? Replace input or output with a pipe.\n");
 		}
@@ -2172,7 +2172,7 @@
 
 	/* multi volume input consistency checking */
 	if ((NumVolumes != 1) && (!Infile))
-		fatal("multi volume support for input needs an explicit given input device (option -i)\n");
+		fatal("multi-volume support for input needs an explicitly specified input device (option -i)\n");
 
 	/* SPW: Volsize consistency checking */
 	if (OutVolsize && !outfile)
@@ -2197,13 +2197,13 @@
 		mxnrsem = SEM_MAX_VALUE;
 #else
 		mxnrsem = LONG_MAX;
-		warningmsg("unable to determine maximum value of semaphores\n");
+		warningmsg("unable to determine the maximum value of semaphores\n");
 #endif
 	}
 	if (Numblocks < 5)
 		fatal("Minimum block count is 5.\n");
 	if (Numblocks > mxnrsem) {
-		fatal("cannot allocate more than %d blocks.\nThis is a system dependent limit, depending on the maximum semaphore value.\nPlease choose a bigger block size.\n",mxnrsem);
+		fatal("cannot allocate more than %d blocks.\nThis is a system-dependent limit, depending on the maximum semaphore value.\nPlease choose a larger block size.\n",mxnrsem);
 	}
 
 	if ((Blocksize * (long long)Numblocks) > (long long)SSIZE_MAX)
@@ -2213,7 +2213,7 @@
 	if (!Buffer)
 		fatal("Could not allocate enough memory (%d requested): %s\n",Numblocks * sizeof(char *),strerror(errno));
 	if (Memmap) {
-		infomsg("mapping temporary file to memory with %llu blocks with %llu byte (%llu kB total)...\n",(unsigned long long) Numblocks,(unsigned long long) Blocksize,(unsigned long long) ((Numblocks*Blocksize) >> 10));
+		infomsg("mapping a temporary file to memory with %llu blocks with %llu byte (%llu kB total)...\n",(unsigned long long) Numblocks,(unsigned long long) Blocksize,(unsigned long long) ((Numblocks*Blocksize) >> 10));
 		if (!Tmpfile) {
 			char tmplname[] = "mbuffer-XXXXXX";
 			char *tmpdir = getenv("TMPDIR") ? getenv("TMPDIR") : "/var/tmp";
@@ -2234,18 +2234,18 @@
 			Tmp = open(Tmpfile,mode,0600);
 		}
 		if (-1 == Tmp)
-			fatal("could not create temporary file (%s): %s\n",Tmpfile,strerror(errno));
+			fatal("could not create a temporary file (%s): %s\n",Tmpfile,strerror(errno));
 		if (strncmp(Tmpfile,"/dev/",5))
 			(void) unlink(Tmpfile);
 		/* resize the file. Needed - at least under linux, who knows why? */
 		if (-1 == lseek(Tmp,Numblocks * Blocksize - sizeof(int),SEEK_SET))
-			fatal("could not resize temporary file: %s\n",strerror(errno));
+			fatal("could not resize the temporary file: %s\n",strerror(errno));
 		if (-1 == write(Tmp,&c,sizeof(int)))
-			fatal("could not resize temporary file: %s\n",strerror(errno));
+			fatal("could not resize the temporary file: %s\n",strerror(errno));
 		Buffer[0] = mmap(0,Blocksize*Numblocks,PROT_READ|PROT_WRITE,MAP_SHARED,Tmp,0);
 		if (MAP_FAILED == Buffer[0])
-			fatal("could not map buffer-file to memory: %s\n",strerror(errno));
-		debugmsg("temporary file mapped to address %p\n",Buffer[0]);
+			fatal("could not map the buffer-file to memory: %s\n",strerror(errno));
+		debugmsg("the temporary file was mapped to address %p\n",Buffer[0]);
 	} else {
 		infomsg("allocating memory for %d blocks with %llu byte (%llu kB total)...\n",Numblocks,(unsigned long long) Blocksize,(unsigned long long) ((Numblocks*Blocksize) >> 10));
 		Buffer[0] = (char *) valloc(Blocksize * Numblocks);
@@ -2253,7 +2253,7 @@
 			fatal("Could not allocate enough memory (%lld requested): %s\n",(unsigned long long)Blocksize * Numblocks,strerror(errno));
 #ifdef MADV_DONTFORK
 		if (-1 == madvise(Buffer[0],Blocksize * Numblocks, MADV_DONTFORK))
-			warningmsg("unable to advise memory handling of buffer: %s\n",strerror(errno));
+			warningmsg("unable to advise the memory handling of the buffer: %s\n",strerror(errno));
 #endif
 	}
 	for (c = 1; c < Numblocks; c++) {
@@ -2271,7 +2271,7 @@
 		if (0 != seteuid(0))
 			warningmsg("could not change to uid 0 to lock memory (is mbuffer setuid root?)\n");
 		else if ((0 != mlock((char *)Buffer,Numblocks * sizeof(char *))) || (0 != mlock(Buffer[0],Blocksize * Numblocks)))
-			warningmsg("could not lock buffer in memory: %s\n",strerror(errno));
+			warningmsg("could not lock the buffer in memory: %s\n",strerror(errno));
 		else
 			infomsg("memory locked successfully\n");
 		err = seteuid(uid);	/* don't give anyone a chance to attack this program, so giveup uid 0 after locking... */
@@ -2295,7 +2295,7 @@
 				In = open(Infile,flags);
 			}
 			if (-1 == In)
-				fatal("could not open input file: %s\n",strerror(errno));
+				fatal("could not open the input file: %s\n",strerror(errno));
 		}
 	} else if (In == -1) {
 		In = STDIN_FILENO;
@@ -2349,13 +2349,13 @@
 	if ((Terminal == 1) && (NumVolumes != 1)) {
 		struct termios tset;
 		if (-1 == tcgetattr(STDERR_FILENO,&tset)) {
-			warningmsg("unable to get terminal attributes: %s\n",strerror(errno));
+			warningmsg("unable to get the terminal attributes: %s\n",strerror(errno));
 		} else {
 			tset.c_lflag &= (~ICANON) & (~ECHO);
 			tset.c_cc[VTIME] = 0;
 			tset.c_cc[VMIN] = 1;
 			if (-1 == tcsetattr(STDERR_FILENO,TCSANOW,&tset))
-				warningmsg("unable to set terminal attributes: %s\n",strerror(errno));
+				warningmsg("unable to set the terminal attributes: %s\n",strerror(errno));
 		}
 	}
 
@@ -2367,13 +2367,13 @@
 	assert(err == 0);
 	sig.sa_flags = SA_RESTART;
 	if (0 != sigaction(SIGINT,&sig,0))
-		warningmsg("error registering new SIGINT handler: %s\n",strerror(errno));
+		warningmsg("error registering the new SIGINT handler: %s\n",strerror(errno));
 	err = sigemptyset(&sig.sa_mask);
 	assert(err == 0);
 	err = sigaddset(&sig.sa_mask,SIGHUP);
 	assert(err == 0);
 	if (0 != sigaction(SIGHUP,&sig,0))
-		warningmsg("error registering new SIGHUP handler: %s\n",strerror(errno));
+		warningmsg("error registering the new SIGHUP handler: %s\n",strerror(errno));
 
 	debugmsg("starting threads...\n");
 	(void) gettimeofday(&Starttime,0);
@@ -2397,33 +2397,33 @@
 	else if (S_ISBLK(st.st_mode) || S_ISCHR(st.st_mode)) {
 		infomsg("blocksize is %d bytes on output device\n",st.st_blksize);
 		if (Blocksize % st.st_blksize != 0) {
-			warningmsg("Blocksize should be a multiple of the blocksize of the output device!\n"
+			warningmsg("The blocksize should be a multiple of the blocksize of the output device!\n"
 				"This can cause problems with some device/OS combinations...\n"
-				"Blocksize on output device is %d (transfer block size is %lld)\n", st.st_blksize, Blocksize);
+				"The blocksize on output device is %d (the transfer block size is %lld)\n", st.st_blksize, Blocksize);
 			if (SetOutsize)
-				fatal("unable to set output blocksize\n");
+				fatal("unable to set the output blocksize\n");
 		} else {
 			if (SetOutsize) {
-				infomsg("setting output blocksize to %d\n",st.st_blksize);
+				infomsg("setting the output blocksize to %d\n",st.st_blksize);
 				Outsize = st.st_blksize;
 			}
 		}
 	} else
-		infomsg("no device on output stream\n");
+		infomsg("no device on the output stream\n");
 	debugmsg("checking input device...\n");
 	if (-1 == fstat(In,&st))
 		warningmsg("could not stat input: %s\n",strerror(errno));
 	else if (S_ISBLK(st.st_mode) || S_ISCHR(st.st_mode)) {
-		infomsg("blocksize is %d bytes on input device\n",st.st_blksize);
+		infomsg("the blocksize is %d bytes on input device\n",st.st_blksize);
 		if (Blocksize % st.st_blksize != 0) {
-			warningmsg("Blocksize should be a multiple of the blocksize of the input device!\n"
-				"Use option -s to adjust transfer block size if you get an out-of-memory error on input.\n"
-				"Blocksize on input device is %d (transfer block size is %lld)\n", st.st_blksize, Blocksize);
+			warningmsg("The blocksize should be a multiple of the blocksize of the input device!\n"
+				"Use option -s to adjust the transfer block size if you get an out-of-memory error on input.\n"
+				"The blocksize on the input device is %d (the transfer block size is %lld)\n", st.st_blksize, Blocksize);
 		}
 	} else
-		infomsg("no device on input stream\n");
+		infomsg("no device on the input stream\n");
 #else
-	warningmsg("Could not stat output device (unsupported by system)!\n"
+	warningmsg("Could not stat the output device (unsupported by the system)!\n"
 		   "This can result in incorrect written data when\n"
 		   "using multiple volumes. Continue at your own risk!\n");
 #endif
@@ -2431,7 +2431,7 @@
 		Status = 0;
 	if (Status) {
 		if (-1 == pipe(TermQ))
-			fatal("could not create termination pipe: %s\n",strerror(errno));
+			fatal("could not create the termination pipe: %s\n",strerror(errno));
 	} else {
 		TermQ[0] = -1;
 		TermQ[1] = -1;
--- a/network.c
+++ b/network.c
@@ -74,7 +74,7 @@
 			size >>= 1;
 		} while ((-1 == err) && (errno == ENOMEM) && (size > osize));
 		if (err == -1) {
-			warningmsg("unable to set socket buffer size: %s\n",strerror(errno));
+			warningmsg("unable to set the socket buffer size: %s\n",strerror(errno));
 			return;
 		}
 	}
@@ -82,9 +82,9 @@
 	err = getsockopt(sock,SOL_SOCKET,buffer,&size,&bsize);
 	assert(err != -1);
 	if (buffer == SO_RCVBUF) 
-		infomsg("set TCP receive buffer size to %d\n",size);
+		infomsg("set the TCP receive buffer size to %d\n",size);
 	else
-		infomsg("set TCP send buffer size to %d\n",size);
+		infomsg("set the TCP send buffer size to %d\n",size);
 }
 
 
@@ -121,7 +121,7 @@
 #endif
 		err = getaddrinfo(host,0,&hint,&cinfo);
 		if (err != 0) 
-			fatal("unable to resolve address information for expected host '%s': %s\n",host,gai_strerror(err));
+			fatal("unable to resolve the address information for the expected host '%s': %s\n",host,gai_strerror(err));
 	}
 	bzero(&hint,sizeof(hint));
 	hint.ai_family = AddrFam;
@@ -130,30 +130,30 @@
 	hint.ai_flags = AI_PASSIVE | AI_ADDRCONFIG;
 	err = getaddrinfo(0,port,&hint,&pinfo);
 	if (err != 0)
-		fatal("unable to get address information for port/service '%s': %s\n",port,gai_strerror(err));
+		fatal("unable to get the address information for port/service '%s': %s\n",port,gai_strerror(err));
 	assert(pinfo);
 	for (x = pinfo; x; x = x->ai_next) {
 		int reuse_addr = 1;
-		debugmsg("creating socket for address familiy %d\n",x->ai_family);
+		debugmsg("creating the socket for address family %d\n",x->ai_family);
 		sock = socket(x->ai_family, SOCK_STREAM, 0);
 		if (sock == -1) {
-			warningmsg("unable to create socket for input: %s\n",strerror(errno));
+			warningmsg("unable to create the socket for input: %s\n",strerror(errno));
 			continue;
 		}
 		if (-1 == setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &reuse_addr, sizeof(reuse_addr)))
-			warningmsg("cannot set socket to reuse address: %s\n",strerror(errno));
+			warningmsg("cannot set the socket to reuse address: %s\n",strerror(errno));
 		if (0 == bind(sock, x->ai_addr, x->ai_addrlen)) {
-			debugmsg("successfully bound socket - address length %d\n",x->ai_addrlen);
+			debugmsg("successfully bound the socket - address length %d\n",x->ai_addrlen);
 			break;
 		}
-		warningmsg("could not bind to socket for network input: %s\n",strerror(errno));
+		warningmsg("could not bind to the socket for network input: %s\n",strerror(errno));
 		(void) close(sock);
 	}
 	if (x == 0)
 		fatal("Unable to initialize network input.\n");
-	infomsg("listening on socket...\n");
+	infomsg("listening on the socket...\n");
 	if (0 > listen(sock,0))		/* accept only 1 incoming connection */
-		fatal("could not listen on socket for network input: %s\n",strerror(errno));
+		fatal("could not listen on the socket for network input: %s\n",strerror(errno));
 	for (;;) {
 		char chost[NI_MAXHOST], serv[NI_MAXSERV];
 		struct sockaddr_in6 caddr;
@@ -161,13 +161,13 @@
 		socklen_t len = sizeof(caddr);
 		int err;
 
-		debugmsg("waiting for incoming connection\n");
+		debugmsg("waiting for an incoming connection\n");
 		In = accept(sock, (struct sockaddr *) &caddr, &len);
 		if (0 > In)
-			fatal("Unable to accept connection for network input: %s\n",strerror(errno));
+			fatal("Unable to accept the connection for network input: %s\n",strerror(errno));
 		err = getnameinfo((struct sockaddr *) &caddr,len,chost,sizeof(chost),serv,sizeof(serv),NI_NUMERICHOST|NI_NUMERICSERV|NI_NOFQDN);
 		if (0 != err) {
-			fatal("unable to get name information for hostname of incoming connection: %s\n",gai_strerror(err));
+			fatal("unable to get the name information for the hostname of the incoming connection: %s\n",gai_strerror(err));
 		}
 		infomsg("incoming connection from %s:%s\n",chost,serv);
 		if (host == 0)
@@ -184,7 +184,7 @@
 			break;
 		warningmsg("rejected connection from %s\n",chost);
 		if (-1 == close(In))
-			warningmsg("error closing rejected input: %s\n",strerror(errno));
+			warningmsg("error closing the rejected input: %s\n",strerror(errno));
 	}
 	freeaddrinfo(pinfo);
 	if (cinfo)
@@ -207,7 +207,7 @@
 	assert(host);
 	port = strrchr(host,':');
 	if (port == 0) {
-		fatal("syntax error - target must be given in the form <host>:<port>\n");
+		fatal("syntax error - the target must be given in the form <host>:<port>\n");
 	}
 	*port++ = 0;
 	bzero(&hint,sizeof(hint));
@@ -218,11 +218,11 @@
 	debugmsg("getting address info for %s\n",addr);
 	err = getaddrinfo(host,port,&hint,&ret);
 	if (err != 0)
-		fatal("unable to resolve address information for '%s': %s\n",addr,gai_strerror(err));
+		fatal("unable to resolve the address information for '%s': %s\n",addr,gai_strerror(err));
 	for (x = ret; x; x = x->ai_next) {
 		fd = socket(x->ai_family, SOCK_STREAM, 0);
 		if (fd == -1) {
-			errormsg("unable to create socket: %s\n",strerror(errno));
+			errormsg("unable to create a socket: %s\n",strerror(errno));
 			continue;
 		}
 		if (0 == connect(fd, x->ai_addr, x->ai_addrlen)) {
@@ -263,56 +263,56 @@
 	debugmsg("openNetworkInput(\"%s\",%hu)\n",host,port);
 	sock = socket(AF_INET, SOCK_STREAM, 6);
 	if (0 > sock)
-		fatal("could not create socket for network input: %s\n",strerror(errno));
+		fatal("could not create a socket for network input: %s\n",strerror(errno));
 	if (-1 == setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &reuse_addr, sizeof(reuse_addr)))
-		warningmsg("cannot set socket to reuse address: %s\n",strerror(errno));
+		warningmsg("cannot set the socket to reuse address: %s\n",strerror(errno));
 	setTCPBufferSize(sock,SO_RCVBUF);
 	if (host[0]) {
-		debugmsg("resolving hostname '%s' of input...\n",host);
+		debugmsg("resolving the hostname '%s' of input...\n",host);
 		if (0 == (h = gethostbyname(host)))
 #ifdef HAVE_HSTRERROR
-			fatal("could not resolve server hostname: %s\n",hstrerror(h_errno));
+			fatal("could not resolve the server hostname: %s\n",hstrerror(h_errno));
 #else
-			fatal("could not resolve server hostname: error code %d\n",h_errno);
+			fatal("could not resolve the server hostname: error code %d\n",h_errno);
 #endif
 	}
 	bzero((void *) &saddr, sizeof(saddr));
 	saddr.sin_family = AF_INET;
 	saddr.sin_addr.s_addr = htonl(INADDR_ANY);
 	saddr.sin_port = htons(port);
-	debugmsg("binding socket to port %d...\n",port);
+	debugmsg("binding the socket to port %d...\n",port);
 	if (0 > bind(sock, (struct sockaddr *) &saddr, sizeof(saddr)))
-		fatal("could not bind to socket for network input: %s\n",strerror(errno));
-	debugmsg("listening on socket...\n");
+		fatal("could not bind to the socket for network input: %s\n",strerror(errno));
+	debugmsg("listening on the socket...\n");
 	if (0 > listen(sock,1))		/* accept only 1 incoming connection */
-		fatal("could not listen on socket for network input: %s\n",strerror(errno));
+		fatal("could not listen on the socket for network input: %s\n",strerror(errno));
 	for (;;) {
 		struct sockaddr_in caddr;
 		socklen_t clen = sizeof(caddr);
 		char **p;
-		debugmsg("waiting to accept connection...\n");
+		debugmsg("waiting to accept a connection...\n");
 		In = accept(sock, (struct sockaddr *)&caddr, &clen);
 		if (0 > In)
-			fatal("could not accept connection for network input: %s\n",strerror(errno));
+			fatal("could not accept a connection for network input: %s\n",strerror(errno));
 		if (host[0] == 0) {
-			infomsg("accepted connection from %s\n",inet_ntoa(caddr.sin_addr));
+			infomsg("accepted a connection from %s\n",inet_ntoa(caddr.sin_addr));
 			(void) close(sock);
 			return;
 		}
 		for (p = h->h_addr_list; *p; ++p) {
 			if (0 == memcmp(&caddr.sin_addr,*p,h->h_length)) {
-				infomsg("accepted connection from %s\n",inet_ntoa(caddr.sin_addr));
+				infomsg("accepted a connection from %s\n",inet_ntoa(caddr.sin_addr));
 				(void) close(sock);
 				return;
 			}
 		}
 		r = gethostbyaddr((char *)&caddr.sin_addr,sizeof(caddr.sin_addr.s_addr),AF_INET);
 		if (r)
-			warningmsg("rejected connection from %s (%s)\n",r->h_name,inet_ntoa(caddr.sin_addr));
+			warningmsg("rejected a connection from %s (%s)\n",r->h_name,inet_ntoa(caddr.sin_addr));
 		else
-			warningmsg("rejected connection from %s\n",inet_ntoa(caddr.sin_addr));
+			warningmsg("rejected a connection from %s\n",inet_ntoa(caddr.sin_addr));
 		if (-1 == close(In))
-			warningmsg("error closing rejected input: %s\n",strerror(errno));
+			warningmsg("error closing the rejected input: %s\n",strerror(errno));
 	}
 }
 
@@ -340,7 +340,7 @@
 		++portstr;
 	}
 	if (1 != sscanf(portstr,"%u",&pnr))
-		fatal("invalid port string '%s' - port must be given by its number, not service name\n", portstr);
+		fatal("invalid port string '%s' - the port must be given by its number, not service name\n", portstr);
 	openNetworkInput(host,pnr);
 }
 
@@ -352,12 +352,12 @@
 	int out;
 	unsigned short pnr;
 
-	debugmsg("creating socket for output to %s:%d...\n",dest->name,dest->port);
+	debugmsg("creating a socket for output to %s:%d...\n",dest->name,dest->port);
 	if (1 != sscanf(dest->port,"%hu",&pnr))
-		fatal("port must be given by its number, not service name\n");
+		fatal("the port must be given by its number, not service name\n");
 	out = socket(PF_INET, SOCK_STREAM, 0);
 	if (0 > out) {
-		errormsg("could not create socket for network output: %s\n",strerror(errno));
+		errormsg("could not create a socket for network output: %s\n",strerror(errno));
 		return;
 	}
 	setTCPBufferSize(out,SO_SNDBUF);
@@ -367,10 +367,10 @@
 	if (0 == (h = gethostbyname(dest->name))) {
 #ifdef HAVE_HSTRERROR
 		dest->result = hstrerror(h_errno);
-		errormsg("could not resolve hostname %s: %s\n",dest->name,dest->result);
+		errormsg("could not resolve the hostname %s: %s\n",dest->name,dest->result);
 #else
-		dest->result = "unable to resolve hostname";
-		errormsg("could not resolve hostname %s: error code %d\n",dest->name,h_errno);
+		dest->result = "unable to resolve the hostname";
+		errormsg("could not resolve the hostname %s: error code %d\n",dest->name,h_errno);
 #endif
 		dest->fd = -1;
 		(void) close(out);
@@ -379,7 +379,7 @@
 	saddr.sin_family = h->h_addrtype;
 	assert(h->h_length <= sizeof(saddr.sin_addr));
 	(void) memcpy(&saddr.sin_addr,h->h_addr_list[0],h->h_length);
-	infomsg("connecting to server at %s...\n",inet_ntoa(saddr.sin_addr));
+	infomsg("connecting to the server at %s...\n",inet_ntoa(saddr.sin_addr));
 	if (0 > connect(out, (struct sockaddr *) &saddr, sizeof(saddr))) {
 		dest->result = strerror(errno);
 		errormsg("could not connect to %s:%d: %s\n",dest->name,dest->port,dest->result);
